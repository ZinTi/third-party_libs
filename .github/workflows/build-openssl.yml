# This starter workflow is for a CMake project running on multiple platforms. There is a different starter workflow if you just want a single platform.
# See: https://github.com/actions/starter-workflows/blob/main/ci/cmake-single-platform.yml
name: OpenSSL on multiple platforms

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      # Set fail-fast to false to ensure that feedback is delivered for all matrix combinations. Consider changing this to true when your workflow is stable.
      fail-fast: false

      # Set up a matrix to run the following 3 configurations:
      # 1. <Windows, Release, latest MSVC compiler toolchain on the default runner image, default generator>
      # 2. <Linux, Release, latest GCC compiler toolchain on the default runner image, default generator>
      # 3. <Linux, Release, latest Clang compiler toolchain on the default runner image, default generator>
      #
      # To add more build types (Release, Debug, RelWithDebInfo, etc.) customize the build_type list.
      matrix:
        os: [ubuntu-latest, windows-latest]
        build_type: [Release]
        c_compiler: [gcc, clang, cl]
        include:
          # Windows + MSVC
          - os: windows-latest
            c_compiler: cl
            cpp_compiler: cl
            generator: "Visual Studio 17 2022"
            arch: "x64"
          # Windows + MinGW
          - os: windows-latest
            c_compiler: gcc
            cpp_compiler: g++
            generator: "MinGW Makefiles"
          # Linux + GCC
          - os: ubuntu-latest
            c_compiler: gcc
            cpp_compiler: g++
            generator: "Unix Makefiles"
          # Linux + Clang
          - os: ubuntu-latest
            c_compiler: clang
            cpp_compiler: clang++
            generator: "Unix Makefiles"
        exclude:
          - os: windows-latest
            c_compiler: clang
          - os: ubuntu-latest
            c_compiler: cl

    steps:
    - uses: actions/checkout@v4

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
      id: strings
      shell: bash
      run: |
          # library sources
          library_name="openssl"
          library_version="3.5.4"
          src_pkg_name="openssl-3.5.4.tar.gz"
          download_url="https://github.com/openssl/openssl/releases/download/openssl-${library_version}/${src_pkg_name}"

          # github repo path
          repo_dir="${{ github.workspace }}"       # 从GitHub上下文获取路径并标准化
          repo_dir="${repo_dir//\\//}"             # 替换所有反斜杠为正斜杠
          repo_dir="${repo_dir%/}"                 # 移除路径末尾的斜杠（若有）

          # release output path
          full_version="v${library_version:-3.x.x}-$(date +'%Y%m%d').${{ github.run_number }}" # 使用语义化版本+日期+构建号
          platform=$(echo $RUNNER_OS | tr '[:upper:]' '[:lower:]')-$(uname -m) # short_os-arch
          if [ "$RUNNER_OS" == "Linux" ]; then
            toolchain="${{ matrix.c_compiler }}"
          elif [ "$RUNNER_OS" == "Windows" ]; then
            if [ "${{ matrix.c_compiler }}" == "cl" ]; then
              toolchain="msvc"
            else
              toolchain="mingw"
            fi
          fi
          release_dir_name="${library_name}-${full_version}-${platform}-${toolchain}"

          # github actions env
          echo "LIB_NAME=$library_name" >> "$GITHUB_OUTPUT"
          echo "LIB_VERSION=$library_version" >> "$GITHUB_OUTPUT"
          echo "SRC_PKG_NAME=$src_pkg_name" >> "$GITHUB_OUTPUT"
          echo "DOWNLOAD_URL=$download_url" >> "$GITHUB_OUTPUT"
          echo "REPO_DIR=$repo_dir" >> "$GITHUB_OUTPUT"
          echo "RELEASE_DIR_NAME=$release_dir_name" >> "$GITHUB_OUTPUT"

          # debug output
          echo "=== GITHUB_OUTPUT ==="
          echo "$GITHUB_OUTPUT"

    - name: Download sources
      shell: bash
      run: |
        curl -k -L --retry 3 --connect-timeout 30 -O ${{ steps.strings.outputs.DOWNLOAD_URL }}
        tar -xzf ${{ steps.strings.outputs.SRC_PKG_NAME }}
        mv openssl-3.5.4 openssl-src

    - name: Build (Windows MSVC)
      if: matrix.os == 'windows-latest' && matrix.c_compiler == 'cl'
      shell: pwsh
      run: |
        # 使用 Developer PowerShell for VS 2022
        $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise"
        $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        
        if (-not (Test-Path $devShellPath)) {
            $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Professional"
            $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        }
        
        if (-not (Test-Path $devShellPath)) {
            $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Community" 
            $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        }
        
        if (Test-Path $devShellPath) {
            Write-Host "Launching Developer PowerShell for Visual Studio..."
            & $devShellPath -Arch amd64
        } else {
            Write-Error "Developer PowerShell for Visual Studio not found"
            exit 1
        }
        
        # 现在在 Developer PowerShell 环境中构建
        Write-Host "Building SQLite with MSVC..."
        
        # 创建输出目录
        # $releaseDir = "${{ steps.strings.outputs.RELEASE_DIR_NAME }}"
        # New-Item -ItemType Directory -Force -Path "$releaseDir\bin"
        # New-Item -ItemType Directory -Force -Path "$releaseDir\lib" 
        # New-Item -ItemType Directory -Force -Path "$releaseDir\include"
        
        # 进入构建目录
        Set-Location "openssl-src"

        # 配置构建
        Write-Host "Configuring build..."
        perl Configure VC-WIN64A-HYBRIDCRT --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl no-ssl3 no-weak-ssl-ciphers -DOPENSSL_USE_NODELETE -D_WIN32_WINNT=0x0A00
        
        # 使用 nmake 构建
        Write-Host "Running nmake..."
        nmake
        
        if ($LASTEXITCODE -ne 0) {
            Write-Error "nmake failed with exit code $LASTEXITCODE"
            exit 1
        }
        
        # 复制构建结果
        Write-Host "Copying build artifacts..."
        # Copy-Item "openssl.exe" "..\$releaseDir\bin\"
        # Copy-Item "openssl.dll" "..\$releaseDir\bin\"
        # Copy-Item "openssl.lib" "..\$releaseDir\lib\"
        # Copy-Item "openssl.h" "..\$releaseDir\include\"
        nmake install
        
        Write-Host "MSVC build completed successfully!"

    - name: Install Strawberry Perl(Windows MinGW)
      if: matrix.os == 'windows-latest' && matrix.c_compiler == 'gcc'
      shell: pwsh
      run: |
        # curl -L -o strawberry-perl.zip "https://github.com/StrawberryPerl/Perl-Dist-Strawberry/releases/download/SP_54201_64bit/strawberry-perl-5.42.0.1-64bit-portable.zip"
        # unzip strawberry-perl.zip -d /c/StrawberryPerl
        # echo "/c/StrawberryPerl/perl/bin" >> $GITHUB_PATH
        # echo "/c/StrawberryPerl/c/bin" >> $GITHUB_PATH
        Get-Command perl -All
        C:\Strawberry\perl\bin\perl.exe -v
        "C:\Program Files\Git\usr\bin\perl.exe" -v

    - name: Build (Other platforms)
      if: matrix.os != 'windows-latest' || matrix.c_compiler != 'cl'
      shell: bash
      run: |
        if [ "$RUNNER_OS" == "Windows" ]; then
          # Windows + MinGW

          mkdir -p ./${{ steps.strings.outputs.RELEASE_DIR_NAME }}
          mkdir -p ./openssl-src/build && cd ./openssl-src/build
          C:/Strawberry/perl/bin/perl.exe ../Configure --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl \
            no-ssl3 no-weak-ssl-ciphers -DOPENSSL_USE_NODELETE \
            CC=${{ matrix.c_compiler }} CXX=${{ matrix.cpp_compiler }} mingw
          find . -name "Makefile" -exec sed -i 's|C:/Program Files/Git/usr/bin/install|/usr/bin/install|g' {} +  # 解决 install 命令空格问题
          mingw32-make -j$(nproc)
          mingw32-make install
        else
          # Linux + GCC/Clang
          mkdir -p ./${{ steps.strings.outputs.RELEASE_DIR_NAME }}
          mkdir -p ./openssl-src/build && cd ./openssl-src/build
          ../Configure --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl \
           -Wl,-rpath,'$(LIBRPATH)' no-ssl3 no-weak-ssl-ciphers -DOPENSSL_USE_NODELETE \
           CC=${{ matrix.c_compiler }} CXX=${{ matrix.cpp_compiler }}
          make -j$(nproc)
          make install
        fi

    - name: Package
      shell: bash
      run: |
        if [ "$RUNNER_OS" == "Windows" ]; then
          7z a -r ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.7z ${{ steps.strings.outputs.RELEASE_DIR_NAME }}
        else
          tar -Jcvf ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.tar.xz ${{ steps.strings.outputs.RELEASE_DIR_NAME }}
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: openssl-${{ matrix.os }}-${{ matrix.c_compiler }}
        path: |
          ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.tar.xz
          ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.7z

