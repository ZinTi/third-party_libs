name: OpenSSL on multiple platforms

on:
  workflow_dispatch:
  # push:
  #   branches: [ "main", "master" ]
  # pull_request:
  #   branches: [ "main", "master" ]

jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      # Set fail-fast to false to ensure that feedback is delivered for all matrix combinations. Consider changing this to true when your workflow is stable.
      fail-fast: false

      # Set up a matrix to run the following 3 configurations:
      # 1. <Windows, Release, latest MSVC compiler toolchain on the default runner image, default generator>
      # 2. <Linux, Release, latest GCC compiler toolchain on the default runner image, default generator>
      # 3. <Linux, Release, latest Clang compiler toolchain on the default runner image, default generator>
      #
      # To add more build types (Release, Debug, RelWithDebInfo, etc.) customize the build_type list.
      matrix:
        os: [ubuntu-latest, windows-latest]
        build_type: [Release]
        c_compiler: [gcc, clang, cl]
        include:
          # Windows + MSVC
          - os: windows-latest
            c_compiler: cl
            cpp_compiler: cl
            generator: "Visual Studio 17 2022"
            arch: "x64"
          # Windows + MinGW
          - os: windows-latest
            c_compiler: gcc
            cpp_compiler: g++
            generator: "MinGW Makefiles"
          # Linux + GCC
          - os: ubuntu-latest
            c_compiler: gcc
            cpp_compiler: g++
            generator: "Unix Makefiles"
          # Linux + Clang
          - os: ubuntu-latest
            c_compiler: clang
            cpp_compiler: clang++
            generator: "Unix Makefiles"
        exclude:
          - os: windows-latest
            c_compiler: clang
          - os: ubuntu-latest
            c_compiler: cl

    steps:
    - uses: actions/checkout@v4

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
      id: strings
      shell: bash
      run: |
          # library sources
          library_name="openssl"
          library_version="3.5.4"
          src_pkg_name="openssl-3.5.4.tar.gz"
          download_url="https://github.com/openssl/openssl/releases/download/openssl-${library_version}/${src_pkg_name}"

          # github repo path
          repo_dir="${{ github.workspace }}"       # 从GitHub上下文获取路径并标准化
          repo_dir="${repo_dir//\\//}"             # 替换所有反斜杠为正斜杠
          repo_dir="${repo_dir%/}"                 # 移除路径末尾的斜杠（若有）

          # release output path
          full_version="v${library_version:-3.x.x}-$(date +'%Y%m%d').${{ github.run_number }}" # 使用语义化版本+日期+构建号
          platform=$(echo $RUNNER_OS | tr '[:upper:]' '[:lower:]')-$(uname -m) # short_os-arch
          if [ "$RUNNER_OS" == "Linux" ]; then
            toolchain="${{ matrix.c_compiler }}"
          elif [ "$RUNNER_OS" == "Windows" ]; then
            if [ "${{ matrix.c_compiler }}" == "cl" ]; then
              toolchain="msvc"
            else
              toolchain="msys2"
            fi
          fi
          release_dir_name="${library_name}-${full_version}-${platform}-${toolchain}"

          # github actions env
          echo "LIB_NAME=$library_name" >> "$GITHUB_OUTPUT"
          echo "LIB_VERSION=$library_version" >> "$GITHUB_OUTPUT"
          echo "SRC_PKG_NAME=$src_pkg_name" >> "$GITHUB_OUTPUT"
          echo "DOWNLOAD_URL=$download_url" >> "$GITHUB_OUTPUT"
          echo "REPO_DIR=$repo_dir" >> "$GITHUB_OUTPUT"
          echo "RELEASE_DIR_NAME=$release_dir_name" >> "$GITHUB_OUTPUT"

          # debug output
          echo "=== GITHUB_OUTPUT ==="
          cat "$GITHUB_OUTPUT"

    - name: Download sources
      shell: bash
      run: |
        curl -k -L --retry 3 --connect-timeout 30 -O ${{ steps.strings.outputs.DOWNLOAD_URL }}
        tar -xvf ${{ steps.strings.outputs.SRC_PKG_NAME }}
        mv openssl-3.5.4 openssl-src

    - name: Build (Windows MSVC)
      if: matrix.os == 'windows-latest' && matrix.c_compiler == 'cl'
      shell: pwsh
      run: |
        # 使用 Developer PowerShell for VS 2022
        $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise"
        $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        
        if (-not (Test-Path $devShellPath)) {
            $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Professional"
            $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        }
        
        if (-not (Test-Path $devShellPath)) {
            $vsInstallPath = "C:\Program Files\Microsoft Visual Studio\2022\Community" 
            $devShellPath = "$vsInstallPath\Common7\Tools\Launch-VsDevShell.ps1"
        }
        
        if (Test-Path $devShellPath) {
            Write-Host "Launching Developer PowerShell for Visual Studio..."
            & $devShellPath -Arch amd64
        } else {
            Write-Error "Developer PowerShell for Visual Studio not found"
            exit 1
        }
        
        # 现在在 Developer PowerShell 环境中构建
        Write-Host "Building OpenSSL with MSVC..."
        
        # 创建输出目录
        # $releaseDir = "${{ steps.strings.outputs.RELEASE_DIR_NAME }}"
        # New-Item -ItemType Directory -Force -Path "$releaseDir\bin"
        # New-Item -ItemType Directory -Force -Path "$releaseDir\lib" 
        # New-Item -ItemType Directory -Force -Path "$releaseDir\include"
        
        # 进入构建目录
        Set-Location "openssl-src"

        # 配置构建
        Write-Host "Configuring build..."
        perl Configure VC-WIN64A-HYBRIDCRT --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl no-ssl3 no-weak-ssl-ciphers -DOPENSSL_USE_NODELETE -D_WIN32_WINNT=0x0A00
        
        # 使用 nmake 构建
        Write-Host "Running nmake..."
        nmake
        
        if ($LASTEXITCODE -ne 0) {
            Write-Error "nmake failed with exit code $LASTEXITCODE"
            exit 1
        }
        
        nmake install
        Write-Host "MSVC build completed successfully!"

    - name: Build (Windows MSYS2 MinGW)
      if: matrix.os == 'windows-latest' && matrix.c_compiler == 'gcc'
      shell: bash
      run: |
        # 更新系统并安装依赖（带重试机制）
        function install_with_retry {
          local max_retries=3
          local retry_delay=10
          local attempt=1
          
          while [ $attempt -le $max_retries ]; do
            echo "Attempt $attempt: $1"
            C:/msys64/usr/bin/bash -lc "$1" && return 0
            sleep $retry_delay
            ((attempt++))
          done
          return 1
        }

        # 更新系统
        install_with_retry "pacman --noconfirm -Sy"
        install_with_retry "pacman --noconfirm -S msys2-keyring"
        install_with_retry "pacman --noconfirm -Syu"

        # 安装必要包 - 使用 msys/perl 而不是 mingw-w64-x86_64-perl
        install_with_retry "pacman --noconfirm -S \
          mingw-w64-x86_64-toolchain \
          msys/perl \
          make \
          nasm \
          git \
          base-devel"

        # 在MSYS2环境中执行后续操作
        C:/msys64/usr/bin/bash -lc "
          # 设置正确的环境
          export MSYSTEM=MINGW64
          export CHERE_INVOKING=1
          export MSYS2_PATH_TYPE=inherit
          
          # 重新加载profile以设置正确环境
          source /etc/profile

          echo '=== System Info ==='
          echo \"Current shell: \$SHELL\"
          echo \"Perl path: \$(which perl)\"
          echo \"Perl version:\"
          perl -v | head -n5
          echo \"Perl platform: \$(perl -e 'print \$^O')\"
          echo \"GCC version: \$(gcc --version | head -n1)\"

          # 进入源码目录
          cd ${{ steps.strings.outputs.REPO_DIR }}/openssl-src
          pwd
          ls -la

          # 检查Configure脚本是否存在
          if [ ! -f Configure ]; then
            echo '错误：找不到Configure脚本！'
            ls -la
            exit 1
          fi

          # 创建构建目录
          mkdir -p build
          cd build

          # 设置locale避免警告
          export LANG=C
          export LC_ALL=C

          # 运行Configure
          echo '=== 开始配置OpenSSL ==='
          perl ../Configure mingw64 \
            --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} \
            --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl \
            no-ssl3 no-weak-ssl-ciphers \
            -DOPENSSL_USE_NODELETE \
            --release

          echo '=== 配置完成，开始编译 ==='
          make -j$(nproc)
          
          echo '=== 编译完成，开始安装 ==='
          make install

          echo '=== OpenSSL 构建完成 ==='
        "

    - name: Build (Linux GCC/Clang)
      if: matrix.os != 'windows-latest'
      shell: bash
      run: |
        # Linux + GCC/Clang
        mkdir -p ./${{ steps.strings.outputs.RELEASE_DIR_NAME }}
        mkdir -p ./openssl-src/build && cd ./openssl-src/build
        ../Configure --prefix=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }} --openssldir=${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}/ssl \
          -Wl,-rpath,'$(LIBRPATH)' no-ssl3 no-weak-ssl-ciphers -DOPENSSL_USE_NODELETE \
          CC=${{ matrix.c_compiler }} CXX=${{ matrix.cpp_compiler }}
        make -j$(nproc)
        make install

    - name: Package
      shell: bash
      run: |
        if [ "$RUNNER_OS" == "Windows" ]; then
          7z a -r ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.7z ${{ steps.strings.outputs.RELEASE_DIR_NAME }}
        else
          tar -cJvf ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.tar.xz ${{ steps.strings.outputs.RELEASE_DIR_NAME }}
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: openssl-${{ matrix.os }}-${{ matrix.c_compiler }}
        path: |
          ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.tar.xz
          ${{ steps.strings.outputs.REPO_DIR }}/${{ steps.strings.outputs.RELEASE_DIR_NAME }}.7z

